#! /usr/bin/env node

var logger = require('./logger');
var configValidator = require('./config-validator');
var configWriter = require('./config-writer');
var fs = require('fs');
var archiver = require('archiver');
var packageJSON = require(process.cwd() + '/package.json');
var widgetFileManifest = require('./widget-file-manifest');
var distDir = process.cwd() + '/dist';

// validate the widget configuration
configValidator.validate(packageJSON);

// don't continue if there are errors
if (configValidator.hasErrors) {
    return;
}

// create the dist directory
if (!fs.existsSync(distDir)) {
    fs.mkdirSync(distDir, 0744);
}

// write the config xml
var configXML = configWriter.write(packageJSON);

// get the files to be packed into the widget
widgetFileManifest.get(process.cwd(), function(dirs, files) {
    // zip it update
    var output = fs.createWriteStream(distDir + '/' + packageJSON.name + '-' + packageJSON.version + '.wgt');
    var archive = archiver('zip');

    // listen for all archive data to be written
    // 'close' event is fired only when a file descriptor is involved
    output.on('close', function() {
        console.log('Signagelive Widget builder has completed successfully');
    });

    // This event is fired when the data source is drained no matter what was the data source.
    // It is not part of this library but rather from the NodeJS Stream API.
    // @see: https://nodejs.org/api/stream.html#stream_event_end
    output.on('end', function() {});

    // good practice to catch warnings (ie stat failures and other non-blocking errors)
    archive.on('warning', function(err) {
        if (err.code === 'ENOENT') {
            // log warning
        } else {
            // throw error
            throw err;
        }
    });

    // good practice to catch this error explicitly
    archive.on('error', function(err) {
        throw err;
    });

    archive.pipe(output);

    // add config.xml
    archive.append(configXML, { name: 'config.xml' });

    // append files in the root
    for (var i = 0; i < files.length; i++) {
        var fullFilePath = process.cwd() + '/' + files[i];
        archive.append(fs.createReadStream(fullFilePath), { name: files[i] });
    }

    // append files in the root
    for (var i = 0; i < dirs.length; i++) {
        var directoryName = dirs[i];
        var fullDirectoryPath = process.cwd() + '/' + directoryName;
        archive.directory(fullDirectoryPath, directoryName);
    }

    archive.finalize();
})